#include <Windows.h>
#include <TlHelp32.h>
#include <iostream>
#include <vector>
#include <conio.h>
#include <d3d11.h>
#include <d3dcompiler.h>
#include <DirectXMath.h>
#include <d2d1_1.h>
#include <wrl/client.h>

#pragma comment (lib, "d3d11.lib")
#pragma comment (lib, "dxgi.lib")
#pragma comment (lib, "d3dcompiler.lib")
#pragma comment (lib, "d2d1.lib")
#pragma comment (lib, "dwrite.lib")

using namespace Microsoft::WRL;

IDXGISwapChain* swapchain = nullptr;
ID3D11Device* dev = nullptr;
ID3D11DeviceContext* devcon = nullptr;
ID3D11RenderTargetView* backbuffer = nullptr;
ComPtr<ID2D1Factory1> pFactory;
ComPtr<ID2D1DeviceContext> pRenderTarget;
ComPtr<ID2D1SolidColorBrush> pBrush;
ComPtr<IDXGISurface> pBackBuffer;

void InitD3D(HWND hWnd);
void InitD2D();
void RenderFrame();
void CleanD3D();
LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
void CreateOverlayWindow(HINSTANCE hInstance, HWND hGameWnd);

void InitD3D(HWND hWnd) {
    DXGI_SWAP_CHAIN_DESC scd = {};
    scd.BufferCount = 1;
    scd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    scd.BufferDesc.Width = 800;
    scd.BufferDesc.Height = 600;
    scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    scd.OutputWindow = hWnd;
    scd.SampleDesc.Count = 1;
    scd.Windowed = TRUE;
    scd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

    HRESULT hr = D3D11CreateDeviceAndSwapChain(
        nullptr,
        D3D_DRIVER_TYPE_HARDWARE,
        nullptr,
        D3D11_CREATE_DEVICE_BGRA_SUPPORT,
        nullptr,
        0,
        D3D11_SDK_VERSION,
        &scd,
        &swapchain,
        &dev,
        nullptr,
        &devcon
    );

    if (FAILED(hr)) {
        std::cerr << "Failed to create device and swap chain: " << std::hex << hr << std::dec << std::endl;
        return;
    }

    ID3D11Texture2D* pBackBufferTexture;
    hr = swapchain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(&pBackBufferTexture));
    if (FAILED(hr)) {
        std::cerr << "Failed to get swap chain buffer: " << std::hex << hr << std::dec << std::endl;
        return;
    }

    hr = dev->CreateRenderTargetView(pBackBufferTexture, nullptr, &backbuffer);
    pBackBufferTexture->Release();
    if (FAILED(hr)) {
        std::cerr << "Failed to create render target view: " << std::hex << hr << std::dec << std::endl;
        return;
    }

    devcon->OMSetRenderTargets(1, &backbuffer, nullptr);

    D3D11_VIEWPORT viewport = {};
    viewport.TopLeftX = 0;
    viewport.TopLeftY = 0;
    viewport.Width = 800;
    viewport.Height = 600;

    devcon->RSSetViewports(1, &viewport);

    InitD2D();
}

void InitD2D() {
    HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, pFactory.GetAddressOf());
    if (FAILED(hr)) {
        std::cerr << "Failed to create D2D factory: " << std::hex << hr << std::dec << std::endl;
        return;
    }

    hr = swapchain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
    if (FAILED(hr)) {
        std::cerr << "Failed to get swap chain buffer: " << std::hex << hr << std::dec << std::endl;
        return;
    }

    D2D1_RENDER_TARGET_PROPERTIES props = D2D1::RenderTargetProperties(
        D2D1_RENDER_TARGET_TYPE_DEFAULT,
        D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED),
        0, 0
    );

    ComPtr<ID2D1RenderTarget> pRT;
    hr = pFactory->CreateDxgiSurfaceRenderTarget(pBackBuffer.Get(), &props, &pRT);
    if (FAILED(hr)) {
        std::cerr << "Failed to create render target: " << std::hex << hr << std::dec << std::endl;
        return;
    }

    hr = pRT.As(&pRenderTarget);
    if (FAILED(hr)) {
        std::cerr << "Failed to convert render target to device context: " << std::hex << hr << std::dec << std::endl;
        return;
    }

    hr = pRenderTarget->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), pBrush.GetAddressOf());
    if (FAILED(hr)) {
        std::cerr << "Failed to create brush: " << std::hex << hr << std::dec << std::endl;
        return;
    }
}

void RenderFrame() {
    const float clearColor[4] = { 0.0f, 0.0f, 0.0f, 0.0f };
    devcon->ClearRenderTargetView(backbuffer, clearColor);

    if (pRenderTarget) {
        pRenderTarget->BeginDraw();
        pRenderTarget->Clear(D2D1::ColorF(D2D1::ColorF::MidnightBlue, 0.0f));
        D2D1_SIZE_F rtSize = pRenderTarget->GetSize();
        D2D1_POINT_2F center = D2D1::Point2F(rtSize.width / 2, rtSize.height / 2);
        pRenderTarget->FillEllipse(D2D1::Ellipse(center, 50.0f, 50.0f), pBrush.Get());
        HRESULT hr = pRenderTarget->EndDraw();
        if (FAILED(hr)) {
            std::cerr << "Failed to end draw: " << std::hex << hr << std::dec << std::endl;
        }
    }

    swapchain->Present(0, 0);
}

void CleanD3D() {
    if (swapchain) swapchain->SetFullscreenState(FALSE, NULL);
    if (backbuffer) backbuffer->Release();
    if (swapchain) swapchain->Release();
    if (dev) dev->Release();
    if (devcon) devcon->Release();
    pFactory.Reset();
    pRenderTarget.Reset();
    pBrush.Reset();
    pBackBuffer.Reset();
}

LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}

void CreateOverlayWindow(HINSTANCE hInstance, HWND hGameWnd) {
    RECT rc;
    GetWindowRect(hGameWnd, &rc);

    WNDCLASSEX wc = {};
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
    wc.lpszClassName = L"OverlayWindowClass";

    RegisterClassEx(&wc);

    HWND hWnd = CreateWindowEx(
        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST,
        L"OverlayWindowClass",
        L"Overlay",
        WS_POPUP,
        rc.left,
        rc.top,
        rc.right - rc.left,
        rc.bottom - rc.top,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    SetLayeredWindowAttributes(hWnd, RGB(0, 0, 0), 0, LWA_COLORKEY);
    ShowWindow(hWnd, SW_SHOW);

    InitD3D(hWnd);

    MSG msg;
    while (TRUE) {
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        if (msg.message == WM_QUIT) break;

        RenderFrame();
    }

    CleanD3D();
}

int main() {
    HINSTANCE hInstance = GetModuleHandle(NULL);

    // Find the game window
    HWND hGameWnd = FindWindow(NULL, L"AssaultCube");
    if (!hGameWnd) {
        std::cerr << "AssaultCube window not found." << std::endl;
        return 1;
    }

    // Create the overlay window
    CreateOverlayWindow(hInstance, hGameWnd);

    return 0;
}